def permute_block(block, key):
    return ''.join([block[k - 1] for k in key])
def permute_block(block, key):
    # Переставляем символы в блоке согласно ключу (индексы с 1)
    return ''.join([block[k - 1] for k in key])

def main():
    # Исходный зашифрованный текст (пробелы сохранены)
    text = (
        "иоце Л ыболепкоыр от сутлйоб кендсоль,юи толбчизвеш йаонлневед шуивон;еерку а еб зеецле и рдолиб опс аоул ,т  яазиеит лман йенлгеик  ртпейт ;ргед ьееут оыв оокп сдинамоаьс ,ло ,актаольсз но а,дреижуаалд вхнаеиы тЭ а.оемидк аничяаалм нн яанеодетад,и я ьгтово блып  евртар омчльнеис аммып аоазчирсик мебарозо,т  омсьтп еелджорт ьйеисатак  ач,янккав  ргуо дав кснчли,аоовбли  уракаим юомшюе ,  лвжаиы,йо нннеынг опецйу йрплзувачо анг лбхам уи.х  о"
    )

    key = [6, 1, 3, 2, 5, 4]  # Ключ перестановки

    # Дополняем пробелами до длины, кратной 6 (без удаления существующих пробелов)
    padding = (6 - (len(text) % 6)) % 6
    text += " " * padding

    # Разбиваем на блоки по 6 символов (пробелы сохраняются)
    blocks = [text[i:i+6] for i in range(0, len(text), 6)]

    # Применяем перестановку к каждому блоку
    decrypted_text = ''.join([permute_block(block, key) for block in blocks])

    # Вывод результата
    print("Расшифрованный текст:")
    print(decrypted_text)

if __name__ == "__main__":
    main()